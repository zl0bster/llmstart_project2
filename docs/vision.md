# Техническое видение

## Технологический стек

### Backend:
- **Python 3.11+** - основной язык
- **aiogram** - современная библиотека для Telegram Bot API
- **SQLite** - база данных (с возможностью миграции на PostgreSQL)
- **SQLAlchemy** - ORM для работы с БД

### AI/ML:
- **OpenRouter API** - доступ к различным LLM через единый интерфейс
- **OpenAI GPT-4** - для анализа текста и изображений
- **Whisper API** - для распознавания речи
- **LangChain** - для работы с LLM

### Инфраструктура:
- **Docker** - контейнеризация
- **Docker Compose** - локальная разработка
- **Railway.com** - облачный хостинг
- **Локальное развертывание** - альтернативный вариант

### Мониторинг:
- **Базовое логирование** - встроенное в aiogram
- **Python logging** - стандартная библиотека логирования

## Принципы разработки

### Философия KISS
- **Максимальная простота решений** - выбираем самое простое решение, которое работает
- **Никакого оверинжиниринга** - не усложняем архитектуру заранее
- **Быстрая проверка гипотез** - MVP для валидации идей

### Итеративная разработка
- **MVP-first подход** - сначала минимально работающая версия
- **Быстрые циклы разработка → тест → обратная связь** - короткие итерации
- **Fail fast, learn fast** - быстрое выявление и исправление ошибок

### Качество кода
- **Приоритет читаемости над оптимизацией** - понятный код важнее быстрого
- **Простые, понятные решения** - избегаем "умных" решений
- **Рефакторинг при необходимости, но не заранее** - рефакторим по мере роста

### Тестирование
- **Покрытие только критичных функций** - тестируем то, что важно
- **Приоритет интеграционных тестов над unit-тестами** - проверяем работу системы
- **Ручное тестирование основных сценариев** - обязательная проверка пользовательских сценариев

### Архитектурные принципы
- **Монолитная архитектура** - без микросервисов на старте
- **Слоистая архитектура** - четкое разделение слоев (API, Business Logic, Data)
- **Telegram аутентификация** - используем встроенную аутентификацию Telegram

### API и интерфейсы
- **Telegram Bot API** - основной интерфейс
- **Веб-интерфейс** - планируется в будущих версиях
- **REST API** - для внутренних нужд и будущего веб-интерфейса

## Структура проекта

```
otk-assistant/
├── app/
│   ├── __init__.py
│   ├── main.py              # Точка входа aiogram приложения
│   ├── bot/                 # Telegram Bot логика
│   │   ├── __init__.py
│   │   ├── handlers/        # Обработчики сообщений
│   │   │   ├── __init__.py
│   │   │   ├── text_handlers.py    # Обработка текста
│   │   │   ├── photo_handlers.py   # Обработка фото
│   │   │   ├── voice_handlers.py   # Обработка голоса
│   │   │   └── command_handlers.py # Команды бота
│   │   ├── keyboards.py     # Inline и Reply клавиатуры
│   │   ├── middlewares.py   # Middleware для aiogram
│   │   └── filters.py       # Кастомные фильтры
│   ├── services/            # Бизнес-логика
│   │   ├── __init__.py
│   │   ├── data_service.py  # Обработка данных
│   │   └── report_service.py # Генерация отчетов
│   ├── clients/             # Внешние API клиенты
│   │   ├── __init__.py
│   │   ├── llm_client.py    # Работа с LLM через OpenRouter
│   │   ├── vision_client.py # Анализ фотографий
│   │   └── speech_client.py # Обработка голосовых сообщений
│   ├── models/              # Модели данных
│   │   ├── __init__.py
│   │   ├── database.py      # SQLAlchemy модели
│   │   └── schemas.py       # Pydantic схемы
│   ├── core/                # Конфигурация
│   │   ├── __init__.py
│   │   ├── config.py        # Настройки
│   │   └── database.py      # Подключение к БД
│   └── utils/               # Утилиты
│       ├── __init__.py
│       └── helpers.py
├── cache/                   # Временные файлы (настраивается в .env)
│   ├── photos/              # Временные фото
│   ├── audio/               # Временные аудио
│   └── temp/                # Другие временные файлы
├── data/                    # База данных и миграции
│   ├── migrations/          # SQLAlchemy миграции
│   └── otk_assistant.db     # SQLite база данных
├── logs/                    # Логи приложения
│   ├── app.log
│   └── error.log
├── tests/                   # Тесты
├── docker/                  # Docker файлы
├── docs/                    # Документация
├── .env                     # Переменные окружения
├── .env.example             # Пример переменных окружения
├── requirements.txt         # Зависимости
├── docker-compose.yml       # Локальная разработка
└── README.md
```

## Архитектура проекта

### Общая архитектура:
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Telegram Bot  │    │   aiogram App   │    │   External APIs │
│   (aiogram)     │◄──►│   (main.py)     │◄──►│   (OpenRouter,  │
│                 │    │                 │    │    Whisper)     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                │
                       ┌─────────────────┐
                       │   SQLite DB     │
                       │   (data/)       │
                       └─────────────────┘
```

### Потоки данных по типам входящих данных:

#### 1. Текстовое сообщение:
```
User → Telegram → aiogram → text_handlers.py → llm_client.py → OpenRouter → 
→ Структурированные данные → Формирование описания → 
→ Подтверждение/Корректировка пользователю → Telegram → User
│
├─ Если подтверждено → data_service.py → SQLite → Уведомление о сохранении
└─ Если откорректировано → llm_client.py → OpenRouter → 
   → Новые структурированные данные → Повторное подтверждение
```

#### 2. Голосовое сообщение:
```
User → Telegram → aiogram → voice_handlers.py → 
→ Сохранение в cache/audio/ → speech_client.py → Whisper API → 
→ Транскрипция → llm_client.py → OpenRouter → 
→ Структурированные данные → Формирование описания → 
→ Подтверждение/Корректировка пользователю → Telegram → User
│
├─ Если подтверждено → data_service.py → SQLite → Уведомление о сохранении
└─ Если откорректировано → llm_client.py → OpenRouter → 
   → Новые структурированные данные → Повторное подтверждение
```

#### 3. Фотография протокола:
```
User → Telegram → aiogram → photo_handlers.py → 
→ Сохранение в cache/photos/ → vision_client.py → GPT-4 Vision → 
→ Анализ изображения → llm_client.py → OpenRouter → 
→ Структурированные данные → Формирование описания → 
→ Подтверждение/Корректировка пользователю → Telegram → User
│
├─ Если подтверждено → data_service.py → SQLite → Уведомление о сохранении
└─ Если откорректировано → llm_client.py → OpenRouter → 
   → Новые структурированные данные → Повторное подтверждение
```

### Сценарии работы:

#### Сценарий 1: Внесение данных о проверке (текст)
1. **Получение текста** от пользователя
2. **Анализ через LLM** - извлечение структурированных данных
3. **Формирование описания** для подтверждения
4. **Запрос подтверждения** у пользователя
5. **Обработка ответа пользователя:**
   - **Если подтверждено** → **Сохранение в SQLite** → Уведомление о сохранении
   - **Если откорректировано** → **Повторный анализ через LLM** → Новое подтверждение

#### Сценарий 2: Внесение данных о проверке (голос)
1. **Получение аудио** от пользователя
2. **Сохранение файла** в cache/audio/
3. **Транскрипция через Whisper**
4. **Анализ текста через LLM**
5. **Формирование описания** для подтверждения
6. **Запрос подтверждения** у пользователя
7. **Обработка ответа пользователя:**
   - **Если подтверждено** → **Сохранение в SQLite** → Уведомление о сохранении
   - **Если откорректировано** → **Повторный анализ через LLM** → Новое подтверждение

#### Сценарий 3: Внесение данных о проверке (фото)
1. **Получение фото** от пользователя
2. **Сохранение файла** в cache/photos/
3. **Анализ изображения через Vision API**
4. **Дополнительный анализ через LLM**
5. **Формирование описания** для подтверждения
6. **Запрос подтверждения** у пользователя
7. **Обработка ответа пользователя:**
   - **Если подтверждено** → **Сохранение в SQLite** → Уведомление о сохранении
   - **Если откорректировано** → **Повторный анализ через LLM** → Новое подтверждение

#### Сценарий 4: Запрос отчета
1. **Получение критериев** от администрации
2. **Запрос данных** из SQLite по критериям
3. **Формирование отчета** через report_service.py
4. **Отправка отчета** пользователю
5. **Логирование запроса** (отчет не сохраняется)

### Ключевые принципы:
- **Данные записываются в SQLite ТОЛЬКО после подтверждения пользователя**
- **При корректировке - повторное обращение к LLM для переанализа**
- **Цикл подтверждения** продолжается до полного согласия пользователя
- **Логирование всех действий** на каждом этапе

## Модель данных

### Основные сущности:

```sql
-- Пользователи бота
users:
  - id (PRIMARY KEY)
  - telegram_id (UNIQUE)
  - name (TEXT)
  - role (TEXT) -- 'inspector', 'admin', 'manager'
  - created_at (DATETIME)

-- Проверки ОТК
inspections:
  - id (PRIMARY KEY)
  - user_id (FOREIGN KEY -> users.id)
  - order_number (TEXT) -- номер заказа
  - date (DATETIME)
  - object_name (TEXT) -- объект проверки
  - type (TEXT) -- тип проверки
  - status (TEXT) -- 'draft', 'completed', 'approved'
  - comments (TEXT) -- комментарии
  - created_at (DATETIME)

-- Результаты проверки
inspection_results:
  - id (PRIMARY KEY)
  - inspection_id (FOREIGN KEY -> inspections.id)
  - field_name (TEXT) -- название поля/параметра
  - value (TEXT) -- значение
  - file_path (TEXT) -- путь к файлу в хранилище
  - file_type (TEXT) -- 'photo', 'audio', 'text'
  - created_at (DATETIME)

-- Отчеты (генерируются по запросу, не хранятся)
reports:
  - id (PRIMARY KEY)
  - user_id (FOREIGN KEY -> users.id)
  - criteria (TEXT) -- критерии отчета
  - period (TEXT) -- 'week', 'month', 'custom'
  - generated_at (DATETIME)
  - content (TEXT) -- содержимое отчета (временное)
```

### Связи:
- **1 пользователь → много проверок** (one-to-many)
- **1 проверка → много результатов** (one-to-many)
- **1 пользователь → много отчетов** (one-to-many)

### Хранение файлов:
- **Уникальные имена**: `{timestamp}_{user_id}_{file_type}_{hash}.{ext}`
- **Структура папок**: `cache/{type}/{year}/{month}/`
- **Пример**: `cache/photos/2024/01/1704067200_123_photo_abc123.jpg`

## Работа с LLM

### LLM клиенты:
1. **llm_client.py** - основной клиент для текстового анализа
2. **vision_client.py** - анализ фотографий протоколов  
3. **speech_client.py** - обработка голосовых сообщений

### Промпты:
- **Специализированные промпты** для разных типов проверок
- **Шаблоны промптов** для разных сценариев
- **Контекст**: только промпт + входящие данные (без истории)

### Валидация:
- **Текстовое описание** всех входящих данных
- **Подтверждение пользователя** перед сохранением
- **Проверка корректности** ответов LLM

### Провайдеры и модели:

#### OpenRouter (облачные):
- **GPT-3.5-turbo** - быстрая обработка текста
- **GPT-4** - качественный анализ
- **GPT-4 Vision** - анализ изображений
- **Claude 3 Haiku** - альтернатива GPT
- **Llama 3.1 8B** - бесплатная модель

#### Ollama (локальные):
- **llama3.1:8b** - базовая модель
- **llama3.1:70b** - мощная модель
- **mistral:7b** - быстрая модель
- **codellama:7b** - для технических задач
- **phi3:3.8b** - компактная модель

#### LM Studio (локальные):
- **Llama 3.1 8B** - основная модель
- **Mistral 7B** - быстрая обработка
- **CodeLlama 7B** - для структурирования данных
- **Phi-3 3.8B** - легковесная модель

### Обработка ошибок:
- **Логирование всех ошибок** API
- **Fallback сообщения** при сбоях
- **Retry механизм** для временных ошибок

### Контроль расходов:
- **Метрики расходов** по моделям
- **Учет токенов** для каждого запроса
- **Логирование стоимости** запросов

### Структура клиентов:
```
clients/
├── base_client.py      # Базовый интерфейс
├── llm_client.py       # Текстовый анализ
├── vision_client.py    # Анализ фото
├── speech_client.py    # Обработка голоса
└── providers/          # Провайдеры
    ├── openrouter.py   # OpenRouter API
    ├── ollama.py       # Ollama локально
    └── lmstudio.py     # LM Studio локально
```

---

## Следующие разделы (к разработке):

- Мониторинг
- Сценарии работы (описание)
- Деплой
- Подход к конфигурированию
- Подход к логгированию
- Подход к проектной документации
- План разработки
