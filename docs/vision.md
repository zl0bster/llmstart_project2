# Техническое видение

## Технологический стек

### Backend:
- **Python 3.11+** - основной язык
- **aiogram** - современная библиотека для Telegram Bot API
- **SQLite** - база данных (с возможностью миграции на PostgreSQL)
- **SQLAlchemy** - ORM для работы с БД

### AI/ML:
- **OpenRouter API** - доступ к различным LLM через единый интерфейс
- **OpenAI GPT-4** - для анализа текста и изображений
- **Whisper API** - для распознавания речи
- **LangChain** - для работы с LLM

### Инфраструктура:
- **Docker** - контейнеризация
- **Docker Compose** - локальная разработка
- **Railway.com** - облачный хостинг
- **Локальное развертывание** - альтернативный вариант

### Мониторинг:
- **Базовое логирование** - встроенное в aiogram
- **Python logging** - стандартная библиотека логирования

## Принципы разработки

### Философия KISS
- **Максимальная простота решений** - выбираем самое простое решение, которое работает
- **Никакого оверинжиниринга** - не усложняем архитектуру заранее
- **Быстрая проверка гипотез** - MVP для валидации идей

### Итеративная разработка
- **MVP-first подход** - сначала минимально работающая версия
- **Быстрые циклы разработка → тест → обратная связь** - короткие итерации
- **Fail fast, learn fast** - быстрое выявление и исправление ошибок

### Качество кода
- **Приоритет читаемости над оптимизацией** - понятный код важнее быстрого
- **Простые, понятные решения** - избегаем "умных" решений
- **Рефакторинг при необходимости, но не заранее** - рефакторим по мере роста

### Тестирование
- **Покрытие только критичных функций** - тестируем то, что важно
- **Приоритет интеграционных тестов над unit-тестами** - проверяем работу системы
- **Ручное тестирование основных сценариев** - обязательная проверка пользовательских сценариев

### Архитектурные принципы
- **Монолитная архитектура** - без микросервисов на старте
- **Слоистая архитектура** - четкое разделение слоев (API, Business Logic, Data)
- **Telegram аутентификация** - используем встроенную аутентификацию Telegram

### API и интерфейсы
- **Telegram Bot API** - основной интерфейс
- **Веб-интерфейс** - планируется в будущих версиях
- **REST API** - для внутренних нужд и будущего веб-интерфейса

## Структура проекта

```
otk-assistant/
├── app/
│   ├── __init__.py
│   ├── main.py              # Точка входа aiogram приложения
│   ├── bot/                 # Telegram Bot логика
│   │   ├── __init__.py
│   │   ├── handlers/        # Обработчики сообщений
│   │   │   ├── __init__.py
│   │   │   ├── text_handlers.py    # Обработка текста
│   │   │   ├── photo_handlers.py   # Обработка фото
│   │   │   ├── voice_handlers.py   # Обработка голоса
│   │   │   └── command_handlers.py # Команды бота
│   │   ├── keyboards.py     # Inline и Reply клавиатуры
│   │   ├── middlewares.py   # Middleware для aiogram
│   │   └── filters.py       # Кастомные фильтры
│   ├── services/            # Бизнес-логика
│   │   ├── __init__.py
│   │   ├── data_service.py  # Обработка данных
│   │   ├── report_service.py # Генерация отчетов (сводки и CSV)
│   │   ├── session_manager.py # Управление сессиями пользователей
│   │   └── media_processor.py # Конвертация медиа в текст
│   ├── clients/             # Внешние API клиенты
│   │   ├── __init__.py
│   │   ├── llm_client.py    # Работа с LLM через OpenRouter
│   │   ├── vision_client.py # Анализ фотографий
│   │   └── speech_client.py # Обработка голосовых сообщений
│   ├── models/              # Модели данных
│   │   ├── __init__.py
│   │   ├── database.py      # SQLAlchemy модели
│   │   └── schemas.py       # Pydantic схемы
│   ├── core/                # Конфигурация
│   │   ├── __init__.py
│   │   ├── config.py        # Настройки
│   │   └── database.py      # Подключение к БД
│   └── utils/               # Утилиты
│       ├── __init__.py
│       └── helpers.py
├── cache/                   # Временные файлы (настраивается в .env)
│   ├── photos/              # Временные фото
│   ├── audio/               # Временные аудио
│   └── temp/                # Другие временные файлы
├── data/                    # База данных и миграции
│   ├── migrations/          # SQLAlchemy миграции
│   └── otk_assistant.db     # SQLite база данных
├── logs/                    # Логи приложения
│   ├── app.log
│   └── error.log
├── tests/                   # Тесты
├── docker/                  # Docker файлы
├── docs/                    # Документация
├── prompts/                 # Шаблоны промптов для LLM
│   ├── __init__.py
│   ├── system_prompts.py    # Системные промпты
│   └── templates/           # Шаблоны для разных типов проверок
├── .env                     # Переменные окружения
├── .env.example             # Пример переменных окружения
├── requirements.txt         # Зависимости
├── docker-compose.yml       # Локальная разработка
└── README.md
```

## Архитектура проекта

### Общая архитектура:
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Telegram Bot  │    │   aiogram App   │    │   External APIs │
│   (aiogram)     │◄──►│   (main.py)     │◄──►│   (OpenRouter,  │
│                 │    │                 │    │    Whisper)     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                │
                       ┌─────────────────┐
                       │   SQLite DB     │
                       │   (data/)       │
                       └─────────────────┘
```

### Детальная архитектура компонентов:

#### 1. **Telegram Bot** - endpoint для получения сообщений
- Обработка текста, голоса, фото
- Управление клавиатурами и кнопками
- Middleware для логирования и сессий

#### 2. **Media Processor** - модуль конвертации медиа в текст
- **Whisper API** для голосовых сообщений (Speech-to-Text)
- **GPT-4 Vision** для анализа фотографий протоколов
- **Tesseract/OCR** как альтернатива для фото

#### 3. **Session Manager** - ядро управления состоянием диалога
- Создание и получение сессий пользователей
- Обновление истории сообщений в сессии
- Управление таймаутами сессий (15 минут)

#### 4. **LLM Orchestrator** (LangChain) - взаимодействие с LLM
- Промт-инжиниринг с системными шаблонами
- Pydantic output parsers для структурированного ответа
- Обработка ошибок парсинга JSON

#### 5. **Data Validator & Storage** - финальная валидация и запись
- Валидация извлеченных данных
- Формирование подтверждающих сообщений
- Запись в БД после подтверждения пользователя

### Потоки данных по типам входящих данных:

#### 1. Текстовое сообщение:
```
User → Telegram Bot → text_handlers.py → Session Manager → 
→ LLM Orchestrator (LangChain) → OpenRouter → 
→ Pydantic Parser → Data Validator & Storage → 
→ Подтверждение/Корректировка пользователю → Telegram Bot → User
│
├─ Если подтверждено → SQLite → Уведомление о сохранении
└─ Если откорректировано → Session Manager → LLM Orchestrator → 
   → Новые структурированные данные → Повторное подтверждение
```

#### 2. Голосовое сообщение:
```
User → Telegram Bot → voice_handlers.py → Media Processor → 
→ Сохранение в cache/audio/ → Whisper API → Транскрипция → 
→ Session Manager → LLM Orchestrator (LangChain) → OpenRouter → 
→ Pydantic Parser → Data Validator & Storage → 
→ Подтверждение/Корректировка пользователю → Telegram Bot → User
│
├─ Если подтверждено → SQLite → Уведомление о сохранении
└─ Если откорректировано → Session Manager → LLM Orchestrator → 
   → Новые структурированные данные → Повторное подтверждение
```

#### 3. Фотография протокола:
```
User → Telegram Bot → photo_handlers.py → Media Processor → 
→ Сохранение в cache/photos/ → GPT-4 Vision → Анализ изображения → 
→ Session Manager → LLM Orchestrator (LangChain) → OpenRouter → 
→ Pydantic Parser → Data Validator & Storage → 
→ Подтверждение/Корректировка пользователю → Telegram Bot → User
│
├─ Если подтверждено → SQLite → Уведомление о сохранении
└─ Если откорректировано → Session Manager → LLM Orchestrator → 
   → Новые структурированные данные → Повторное подтверждение
```

### Сценарии работы:

#### Сценарий 1: Внесение данных о проверке (текст)
1. **Получение текста** от пользователя
2. **Анализ через LLM** - извлечение структурированных данных
3. **Формирование описания** для подтверждения
4. **Запрос подтверждения** у пользователя
5. **Обработка ответа пользователя:**
   - **Если подтверждено** → **Сохранение в SQLite** → Уведомление о сохранении
   - **Если откорректировано** → **Сохранение диалога** → **Повторный анализ через LLM с контекстом диалога** → Новое подтверждение

#### Сценарий 2: Внесение данных о проверке (голос)
1. **Получение аудио** от пользователя
2. **Сохранение файла** в cache/audio/
3. **Транскрипция через Whisper**
4. **Анализ текста через LLM**
5. **Формирование описания** для подтверждения
6. **Запрос подтверждения** у пользователя
7. **Обработка ответа пользователя:**
   - **Если подтверждено** → **Сохранение в SQLite** → Уведомление о сохранении
   - **Если откорректировано** → **Сохранение диалога** → **Повторный анализ через LLM с контекстом диалога** → Новое подтверждение

#### Сценарий 3: Внесение данных о проверке (фото)
1. **Получение фото** от пользователя
2. **Сохранение файла** в cache/photos/
3. **Анализ изображения через Vision API**
4. **Дополнительный анализ через LLM**
5. **Формирование описания** для подтверждения
6. **Запрос подтверждения** у пользователя
7. **Обработка ответа пользователя:**
   - **Если подтверждено** → **Сохранение в SQLite** → Уведомление о сохранении
   - **Если откорректировано** → **Сохранение диалога** → **Повторный анализ через LLM с контекстом диалога** → Новое подтверждение

#### Сценарий 4: Запрос отчета
1. **Получение критериев** от администрации
2. **Запрос данных** из SQLite по критериям
3. **Формирование отчета** через report_service.py
4. **Отправка отчета** пользователю
5. **Логирование запроса** (отчет не сохраняется)

### Ключевые принципы:
- **Данные записываются в SQLite ТОЛЬКО после подтверждения пользователя**
- **При корректировке - повторное обращение к LLM для переанализа**
- **Цикл подтверждения** продолжается до полного согласия пользователя
- **Логирование всех действий** на каждом этапе

### Архитектурные принципы:
- **Polling-подход** для получения сообщений от Telegram
- **Простая обработка ошибок** (try-catch блоки)
- **Синхронная обработка сообщений** - один поток, последовательная обработка
- **Сессия работы с пользователем** включает все сообщения, отправленные за последнее время с коротким промежутком и связанные с одним номером заказа или проверкой
- **Таймаут сессий** - 15 минут бездействия автоматически завершает сессию
- **Валидация данных** - всегда требует подтверждения пользователя перед сохранением
- **Обработка ошибок LLM** - fallback к запросу уточнения при сбоях парсинга

## Модель данных

### Основные сущности:

```sql
-- Пользователи бота
users:
  - id (PRIMARY KEY)
  - telegram_id (UNIQUE)
  - name (TEXT)
  - role (TEXT) -- 'inspector', 'admin', 'manager'
  - created_at (DATETIME)

-- Проверки ОТК (заказы)
inspections:
  - id (PRIMARY KEY)
  - user_id (FOREIGN KEY -> users.id)
  - session_id (TEXT) -- ID сессии диалога
  - order_id (TEXT) -- номер заказа (4-5 цифр)
  - status (TEXT) -- 'годно', 'в доработку', 'в брак'
  - comment (TEXT) -- комментарий контролера к статусу
  - created_at (DATETIME)

-- Диалоги с пользователями
dialogues:
  - id (PRIMARY KEY)
  - user_id (FOREIGN KEY -> users.id)
  - inspection_id (FOREIGN KEY -> inspections.id)
  - session_id (TEXT) -- уникальный ID сессии диалога
  - user_message (TEXT) -- сообщение пользователя
  - llm_response (TEXT) -- ответ LLM
  - system_prompt (TEXT) -- системный промпт, использованный для запроса
  - status (TEXT) -- 'pending', 'confirmed', 'corrected'
  - created_at (DATETIME)

```

### Связи:
- **1 пользователь → много проверок** (one-to-many)
- **1 пользователь → много диалогов** (one-to-many)

### Хранение файлов:
- **Уникальные имена**: `{timestamp}_{user_id}_{file_type}_{hash}.{ext}`
- **Структура папок**: `cache/{type}/{year}/{month}/`
- **Пример**: `cache/photos/2024/01/1704067200_123_photo_abc123.jpg`

## Работа с LLM

### LLM клиенты:
1. **llm_client.py** - основной клиент для текстового анализа
2. **vision_client.py** - анализ фотографий протоколов  
3. **speech_client.py** - обработка голосовых сообщений

### Промпты:
- **Специализированные промпты** для разных типов проверок
- **Шаблоны промптов** для разных сценариев
- **Контекст**: только промпт + входящие данные (без истории)

### Валидация:
- **Текстовое описание** всех входящих данных
- **Подтверждение пользователя** перед сохранением
- **Проверка корректности** ответов LLM

### Провайдеры и модели:

#### OpenRouter (облачные):
- **GPT-3.5-turbo** - быстрая обработка текста
- **GPT-4** - качественный анализ
- **GPT-4 Vision** - анализ изображений
- **Claude 3 Haiku** - альтернатива GPT
- **Llama 3.1 8B** - бесплатная модель

#### Ollama (локальные):
- **llama3.1:8b** - базовая модель
- **llama3.1:70b** - мощная модель
- **mistral:7b** - быстрая модель
- **codellama:7b** - для технических задач
- **phi3:3.8b** - компактная модель

#### LM Studio (локальные):
- **Llama 3.1 8B** - основная модель
- **Mistral 7B** - быстрая обработка
- **CodeLlama 7B** - для структурирования данных
- **Phi-3 3.8B** - легковесная модель

### Обработка ошибок:
- **Логирование всех ошибок** API
- **Fallback сообщения** при сбоях
- **Retry механизм** для временных ошибок

### Контроль расходов:
- **Метрики расходов** по моделям
- **Учет токенов** для каждого запроса
- **Логирование стоимости** запросов

### Структура клиентов:
```
clients/
├── base_client.py      # Базовый интерфейс
├── llm_client.py       # Текстовый анализ
├── vision_client.py    # Анализ фото
├── speech_client.py    # Обработка голоса
└── providers/          # Провайдеры
    ├── openrouter.py   # OpenRouter API
    ├── ollama.py       # Ollama локально
    └── lmstudio.py     # LM Studio локально
```

### Pydantic модели для LLM:
```python
from pydantic import BaseModel, Field
from typing import List, Optional
from enum import Enum

class StatusEnum(str, Enum):
    approved = "годно"
    rework = "в доработку"
    reject = "в брак"

class OrderData(BaseModel):
    order_id: str = Field(description="Номер заказа, строка из 4-5 цифр, извлеченная из текста")
    status: Optional[StatusEnum] = Field(description="Статус проверки изделия")
    comment: Optional[str] = Field(description="Комментарий контролера к статусу")

class LLMResponse(BaseModel):
    orders: List[OrderData] = Field(description="Список распознанных заказов и их статусов")
    requires_correction: bool = Field(description="Флаг, что данные неполные и требуется уточнение у пользователя")
    clarification_question: Optional[str] = Field(description="Сформулированный вопрос пользователю для уточнения, если requires_correction=True")
```

**Примечание**: `requires_correction` и `clarification_question` - это флаги для обмена с LLM, они НЕ сохраняются в базе данных, а используются только для валидации и уточнения данных.

### Системные промпты:
- **Специализированные промпты** для извлечения номеров заказов и статусов
- **Контекстная обработка** с учетом истории диалога
- **Fallback промпты** для случаев неполных данных
- **Валидация ответов** через Pydantic схемы

## Мониторинг

### Базовое логирование:
- **Python logging** - стандартная библиотека
- **Уровни логирования**: DEBUG, INFO, WARNING, ERROR, CRITICAL
- **Ротация логов** - ежедневная с архивированием старых файлов
- **Форматирование**: время, уровень, модуль, сообщение

### Структура логов:
```
logs/
├── app.log          # Основные события приложения
├── error.log        # Только ошибки и критические события
├── llm.log          # Запросы к LLM API и их результаты
├── user.log         # Действия пользователей
└── archived/        # Архивные файлы логов
    ├── app_2024-01-15.log
    └── error_2024-01-15.log
```

### Что логируется:
1. **Пользовательские действия**: получение сообщений, подтверждения, корректировки
2. **LLM запросы**: отправленные промпты, полученные ответы, время выполнения
3. **Ошибки API**: сбои OpenRouter, Whisper, Telegram API
4. **Операции с БД**: создание записей, обновления, ошибки
5. **Системные события**: запуск/остановка бота, конфигурация
6. **Создание отчетов**: обязательное логирование с указанием пользователя, типа отчета и периода

### Подход к мониторингу:
- **Метрики**: Отслеживание не требуется на начальном этапе
- **Алерты**: Достаточно логирования и сообщений пользователю об ошибках
- **Дашборд**: Веб-интерфейс не планируется
- **Хранение**: Логи хранятся 1 неделю с автоматическим удалением
- **Просмотр**: Через команды Linux/Windows или текстовые редакторы

### Простое решение:
- **Логи в файлы** - без внешних систем мониторинга
- **Обработка ошибок** - автоматические повторы и fallback сообщения
- **Уведомления пользователей** - сообщения в Telegram чат при ошибках
- **Ротация логов** - автоматическое удаление файлов старше недели

---

## Сценарии работы (детальное описание)

### Сценарий 1: Внесение данных о проверке (текст)

**Участники**: Работник ОТК, ИИ-ассистент  
**Цель**: Зафиксировать результаты проверки в структурированном виде

**Детальный процесс**:
1. **Инициация**: Работник отправляет текстовое сообщение с описанием проверки
2. **Создание сессии**: Session Manager создает новую сессию с уникальным session_id
3. **Обработка LLM**: 
   - Текст передается в LLM Orchestrator с системным промптом
   - LLM возвращает структурированные данные через Pydantic parser
   - Извлекаются номера заказов, статусы, комментарии
4. **Валидация**: 
   - Если requires_correction=True - отправляется clarification_question
   - Если данные полные - формируется подтверждающее сообщение
5. **Подтверждение**: 
   - Кнопки "Согласен" / "Исправить" / "Отменить"
   - При "Исправить" - цикл повторяется с сохранением диалога

### Сценарий 2: Внесение данных о проверке (голос)

**Детальный процесс**:
1. **Инициация**: Работник отправляет голосовое сообщение
2. **Media Processing**: 
   - Сохранение файла в cache/audio/
   - Отправка в Whisper API для транскрипции
   - Получение текстовой версии сообщения
3. **Обработка текста**: Аналогично текстовому сценарию
4. **Подтверждение и сохранение**: Стандартный цикл валидации

### Сценарий 3: Внесение данных о проверке (фото)

**Детальный процесс**:
1. **Инициация**: Работник отправляет фотографию протокола
2. **Vision Processing**:
   - Сохранение файла в cache/photos/
   - Отправка в GPT-4 Vision для анализа изображения
   - Извлечение текста и данных с фото
3. **Дополнительный анализ**: Передача извлеченных данных в LLM
4. **Подтверждение и сохранение**: Стандартный цикл валидации

### Сценарий 4: Запрос отчета

**Предопределенные отчеты (4 типа)**:
1. **Сводка за сутки** - статистика по пользователям за день
2. **Сводка за неделю** - статистика по пользователям за неделю  
3. **Данные за сутки** - CSV файл с данными за день
4. **Данные за неделю** - CSV файл с данными за неделю

**Детальный процесс**:
1. **Инициация**: Пользователь выбирает тип отчета из меню бота
2. **Обработка запроса**:
   - **Для сводок**: Запрос данных из БД по периодам и пользователям
   - **Для данных**: Формирование CSV файла из таблицы inspections
3. **Генерация отчета**:
   - **Сводка**: Текстовое сообщение с статистикой по каждому контролеру ОТК:
     - Количество выполненных проверок
     - Из них: годно / в доработку / в брак
   - **Данные**: CSV файл с полными данными проверок
4. **Отправка**: 
   - **Сводка**: Текстовое сообщение в чат
   - **Данные**: Отправка CSV файла
5. **Логирование**: Обязательная запись создания отчета с указанием пользователя

---

## Следующие разделы (к разработке):

- Деплой
- Подход к конфигурированию
- Подход к логгированию
- Подход к проектной документации
- План разработки
